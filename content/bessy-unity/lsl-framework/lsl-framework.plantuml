@startuml lsl-framework
!theme plain
title
LSL Framework
end title

namespace LSLFramework {
    class LSLStreamReader {
        string StreamType = "BCI_Essentials_Predictions"
        bool PrintLogs
        ..serialized fields..
        - bool _openOnStart
        ..properties..
        int SamplesAvailable
        bool HasLiveInlet
        --
        void OpenStream()
        void CloseStream()
        Response[] PullAllResponses()
    }

    class ResponseProvider extends LSLStreamReader {
        float PollingPeriod
        ..properties..
        bool IsPolling
        --
        void SubscribePredictions(Action<Prediction>)
        void SubscribeAll(Action<Response>)
        void Subscribe<T : Response>(Action<T>)
        bool UnsubscribePredictions(Action<Prediction>)
        bool UnsubscribeAll(Action<Response>)
        bool Unsubscribe<T : Response>(Action<T>)
    }

    note bottom
        Convenience class providing
        LSL responses through typed
        callback subscriptions
    end note


    class LSLStreamWriter {
        string StreamName = "UnityMarkerStream"
        string StreamType = "BCI_Essentials_Markers"
        bool PrintLogs
        ..properties..
        bool HasConsumers
        --
        bool OpenStream()
        void CloseStream()
        void PushString(string)
    }

    class MarkerWriter extends LSLStreamWriter {
        status markers
        ..
        void PushTrialStartedMarker()
        void PushTrialEndsMarker()
        void PushTrainingCompleteMarker()
        void PushTrainClassifierMarker()
        void PushUpdateClassifierMarker()
        void PushDoneWithRestingStateCollectionMarker()
        void PushStatusMarker<T : IStatusMarker>()
        --
        event markers
        ..
        void PushMITrainingMarker(...)
        void PushMIClassificationMarker(...)
        ..
        void PushSSVEPTrainingMarker(...)
        void PushSSVEPClassificationMarker(...)
        ..
        void PushSingleFlashP300TrainingMarker(...)
        void PushSingleFlashP300ClassificationMarker(...)
        void PushMultiFlashP300TrainingMarker(...)
        void PushMultiFlashP300ClassificationMarker(...)
        --
        void PushMarker(IMarker)
    }


    class LSLStreamResolver {
        {static} bool TryResolveByType(string, out StreamInfo)
        {static} bool TryResolveByName(string, out StreamInfo)
        {static} bool TryResolveByProperty(string, string, StreamInfo)
        {static} bool TryResolveByPredicate(string, StreamInfo)
        --
        {static} IEnumerator RunResolveByType(string, Action<StreamInfo> float)
        {static} IEnumerator RunResolveByName(string, Action<StreamInfo>, float)
        {static} IEnumerator RunResolveByProperty(string, string, Action<StreamInfo>, float)
        {static} IEnumerator RunResolveByPredicate(string, Action<StreamInfo>, float)
    }


    interface IMarker {
        string MarkerString
    }

    interface IStatusMarker extends IMarker

    circle "...Specialized Status Markers" as status_markers implements IStatusMarker

    abstract EventMarker implements IMarker {
        int ObjectCount
        int TrainingTarget
    }

    abstract EpochEventMarker extends EventMarker {
        float EpochLength
    }
    class MIEventMarker extends EpochEventMarker

    class SSVEPEventMarker extends EpochEventMarker {
        float[] Frequencies
    }

    abstract P300EventMarker extends EventMarker
    class SingleFlashP300EventMarker extends P300EventMarker {
        int ActiveObject
    }
    class MultiFlashP300EventMarker extends P300EventMarker {
        int[] ActiveObjects
    }


    class Prediction extends SingleChannelResponse {
        int Index
        float[] Probabilities
    }
    note bottom of Prediction: The only useful response

    class CompositePrediction extends Prediction
    {
        Prediction[] Parts
    }
    CompositePrediction *-- Prediction


    class Response {
        double CaptureTime
        string[] RawSampleValues
        {static} Response BuildResponse(string[], double)
        string ToString()
        bool TryMatchRegex(...)
    }
    class EmptyResponse extends Response

    class SingleChannelResponse extends Response {
        {static} Response Parse(string)
    }
    class LSLPing extends SingleChannelResponse

    class LSLMarkerReceipt extends SingleChannelResponse
}


MarkerWriter --> IMarker
LSLStreamReader --> Response
LSLStreamReader --> LSLStreamResolver
ResponseProvider --> Prediction

@enduml